

'''

1로 만들기 설계

문제 :
정수 x가 주어질 때
정수 x에 사용할 수 있는 연산은 4가지이다.
1. x가 5로 나누어 떨어지면 5로 나눈다.
2. x가 3으로 나누어 떨어지면 3으로 나눈다.
3. x가 2로 나누어 떨어지면 2로 나눈다.
4. x에서 1을 뺀다.

정수 x 가 주어졌을 때
연산 4개를 적절히 사용해서 1을 만들려고 한다.
연산을 사용하는 횟수의 최소값을 구하시오



입력 :
1. x [1,30000]



출력 :
1. 연산을 하는 횟수의 최소값



아이디어 : 다이나믹 프로그래밍 적용하여 풀기

<다이나믹 프로그램 조건 2가지>
  1. 최적의 부분 구조 :
    큰 문제를 작은 문제로 나눌 수 있으며 작은 문제의 답을 모아서 큰 문제를 해결할 수 있다.
  2. 중복되는 부분 문제 :
    동일한 작은 문제를 반복적으로 해결해야 한다.

1. 어떻게 하면 이 문제를 작은 문제로 나눌 수 있을까?
작은 문제 4가지 경우의 수 중에 어떤 것을 선택해야하는지

2. 어떻게 하면 그 작은 문제를 모아서 이 문제를 해결할 수 있을까?
완전탐색으로 모든 경우의 수를 확인하면 된다. (완전탐색)

3. 반복되는 동일한 작은 문제는 어떤 것이 있을까?
N이 최대 3만이므로 최대 3만개의 동일한 작은 문제가 생길 수 있다.

일단 반복문으로 한번 구현해보고 난 후에
재귀함수로 다시 구현해봐야겠다.

바텀업 방식인 상향식으로 구현하기위해서
1부터 시작해서 아래와 같은 연산을 수행하겠다.
1. 5를 곱한다
2. 3을 곱한다.
3. 2를 곱한다.
4. 1을 더한다.


설계 :

1. 입력 받기
2. 크기가 3만인 중복 확인 리스트 만들기
3. while list[x]==0 and queue:
    큐에서 값을 하나 빼서
    해당 값에 연산 4개를 하며 반복하고
    연산을 한 값을 인덱스로하는 list 값이 0이고 인덱스값이 30000보다 작거나 같으면
    해당 인덱스의 값을 연산횟수로 초기화하고 큐에 넣는다.
    아니면 패스
4. list[x] 출력

내가 구현한 코드 :

from collections import deque

x = int(input())

n_list = [0] * 30010

count = 0
queue = deque([[1, count]])

while n_list[x] == 0 and queue:

    current_node = queue.popleft()

    check = []

    check.append(current_node[0] * 5)
    check.append(current_node[0] * 3)
    check.append(current_node[0] * 2)
    check.append(current_node[0] + 1)
    current_node[1] += 1

    for i in range(4):
        if check[i]>30000:
            continue
        if n_list[check[i]] == 0:
            n_list[check[i]] = current_node[1]
            queue.append([check[i], current_node[1]])

print(n_list[x])

피드백 :
저자는 2부터 x까지 카운트를 모두 계산해서 리스트에 초기화하는 방식으로
바텀업 방식을 구현하였다.

저자가 세운 이 문제의 점화식은 " a(i) = min(a(i-1),a(i/2),a(i/3),a(i/5))+1 " 이다.

저자가 구현한 간단한 코드를 숙지하도록 하자


저자가 구현한 코드 :

x=int(input())

d=[0]*30001

for i in range(2,x+1):

    d[i]=d[i-1]+1

    if i%2==0:
        d[i] == min(d[i], d[i // 2] + 1)
    if i%3==0:
        d[i] == min(d[i], d[i // 3] + 1)
    if i%5==0:
        d[i] == min(d[i], d[i // 5] + 1)

print(d[x])



'''




'''

개미 전사 설계

문제:

메뚜기 마을의 식량창고는 일직선으로 이어져 있다.
개미전사는 식량창고를 선택적으로 약탈하여 식량을 뺴앗을 예정이다.
메뚜기 정찰병들은 일직선상에 존재하는 식량 창고 중에서 
서로 인접한 식량창고가 공격 받으면 바로 알아챌수 있다.
따라서 정찰병에게 들키지 않기 위해서 최소 한칸 이상 떨어진 식량창고를 약탈해야한다.
개미전사는 최대한 많은 식량을 얻기를 원한다.
N개의 식량창고의 정보가 주어졌을때 식량의 최대값을 구하는 프로그램을 작성하시오






입력 :
1. 식량창고의 개수N [3,100]
2. 식량창고의 정보 [0,1000]





출력 :
최대값





아이디어 :
다이나믹 프로그래밍 이용
다이나믹 프로그래밍을 이용해야 하는지 파악하려면
완전탐색으로 구현했을때 시간이 너무 오래 걸리는지 확인하고
너무 오래걸린다면 해겨하고자하는 부분 문제들의 중복여부를 확인하는 것이다.

이 문제에서는 각 인덱스당 최대값을 모두 중복해서 계산하면 너무 오랜시간이 걸리고
인덱스 당 최대값을 구하는 것이 작은 문제이고 중복되는 문제이다.
위의 이유들로부터 이 문제를 다이나믹 프로그래밍을 적용해서 풀어야함을 파악할 수 있다. 

식량고의 개수-3만큼 반복한다.
최대값이므로 3개 이상의 공백의 칸이 있어서는 안된다.
인덱스가 0 일때의 최대값은 정해져있다.
나머지 경우의 예로 인덱스가 3일때는 
인데스가 3인 값에 인덱스가 1일떄의 최대값과 0일때의 최대값 중에 큰 값을 더한다.
n일때는 n-2와 n-3 중에서 큰 값을 더한다. 
max()함수 이용하기




설계:
1. 입력받기 n,n_list=[]
2. 최대값을 저장할 리스트 만들기 max_list=[] 
3. 식량창고의 개수 - 3 번 반복하기
4. max_list[i]=n_list[i]+max(max_list[i-2],max_list[i-3])
5. max(max_list[n-1],max_list[n-2]) 출력하기





내가 구현한 코드 :



(n의 크기가 3이상이고 3이어도 마지막에 2와 비교하기 때문에 상관없다.)

n=int(input())

n_list=list(map(int,input().split()))

max_list=[0]*n

max_list[0]=n_list[0]
max_list[1]=n_list[1]
max_list[2]=n_list[2]+max_list[0]

for i in range(3,n):
    max_list[i] = n_list[i] + max(max_list[i - 2], max_list[i - 3])


print(max(max_list[n-1],max_list[n-2]))

피드백 :
이번에는 큐를 이용하여 구현하지 않고
저자의 "1로 만들기"의 코드를 떠올려서 이번 문제를 구현했다.
나는 각 인덱스의 최대값을 모두 구한 후에
비교 연산을 한 번 더했는데 
저자는 사전에 세워놓은 점화식을 이용하여 더 간단하게 구현했다.

만약 순차적으로 각 인덱스마다 최대값을 구해야한다면 저자와 같이 구현해야한다.




저자의 문제 해설을 보니 생각의 흐름이 
문제가 어떤 유형인지 파악을 먼저 하고 
그 유형에 맞추어서 미리 체계적으로 계획해 놓은 방식으로 푼다.


즉, 다이나믹 프로그래밍임을 파악하고
점화식을 세울 궁리를 한다.


나도 이렇게 체계적으로 문제를 푸는 순서를 계획하고
연습해야 시간에 쫓기지 않고 풀 수 있을 것 같다는 생각이 든다.


나는 문제의 규칙을 찾았지만 그 규칙을 이용하여 점화식을 세우지는 않았다.
다음에 다이나미 프로그래밍을 풀때는 점화식을 세워봐야겠다.




<저자가 세운 점화식>
a(i)=max(a(i-1),a(i-2)+k(i))

a(i)는 i번째 인덱스까지 계산한 최대값이고
k(i)는 i번째 인덱스에 저장되어있는 값이다.




저자가 구현한 코드 :

n=int(input())

array=list(map(int,input().split()))

d=[0]*100

d[0]=array[0]
d[1]=max(array[0],array[1])

for i in range(2,n):
    d[i] = max(d[i - 1], d[i - 2]+array[i])


print(d[n-1])

'''



'''

바닥 공사 설계

문제 :
가로 n 세로 2인 직사각형이 있다.
이 직사각형을 1*2,2*1,2*2를 이용하여 채우려고 한다.
이때 바닥을 채우는 모든 경우의 수를 구하는 프로그램을 작성해라

입력 :
1. n

출력 :
1. 바닥을 채우는 방법의 경우의 수 % 796796

아이디어 :
다이나믹 프로그래밍 문제의 아이디어를 찾을 때 
경우의 수를 고려해서 트리를 그려보는 것이 도움이 되는 것 같다.

덮개를 까는 방법은 3가지가 있고 이 3가지는 각각 1 ,2, 2 만큼 직사각형을 덮을 수 있다.

점화식을 세워 보면 아래와 같다.

a(1)=1
a(2)=3
n>3일때
a(n) = a(n-1) + 2a(n-2) 이고 
이 식은 아래와 같이 나타낼 수 있다.

a(n) + a(n-1) =2*( a(n-1) + a(n-2) )

a(n) + a(n-1)을 T(n)으로 치환하면
T(n)=2*T(n-1)이고 
T(2) = a(2) + a(1) = 4
T(3) = 2^3 이므로
T(n) = 2^n 이다.

T(n) - T(n-1) + T(n-2) ... + (-1)^(n-2)*T(2) 
= a(n) + a(n-1) - a(n-1) - a(n-2) + a(n-2) + a(n-3) ...
= a(n) + (-1)^(n)*a(1)
= a(n) + (-1)^(n)
= ABS(k=1 부터 k=n-1 까지 (-2)^(k+1)의 합)

따라서 a(n) = (-1)^(n+1) +ABS(k=1 부터 k=n-1 까지 (-2)^(k+1)의 합)
= (-1)^(n+1) +ABS( ((4-(-2)^(n+1)) / 3)

컴퓨터의 빠른 반복을 이용하는 방법으로 알고리즘을 설계하면
남은 길이가 n일때 인덱스가 n인 값이 0이 아니면 연산하지 않고 해당 인덱스의 값을 사용한다.

그냥 완전 탐색으로 찾으려면 시간 복잡도가 O(3^n)이므로 시간초과이다.
그리고 작은 문제들이 합쳐서 큰 문제가 되므로 
다이나믹 프로그래밍을 이용하는 문제인 것을 알 수 있다.


설계 :

1. 입력받기
2. 반복되는 값들을 저장할 n_list 만들기
3. 반복되는 값이 현재 계산 중인지 체크하는 check_list 만들기
4. 인덱스가 n인 리스트 값이 저장이 되면 반복문을 종료한다.
5.   a(n) = a(n-1) + 2a(n-2) 을 구현한다.
6. 값을 출력한다.

내가 처음 구현한 코드 :

n=int(input())

n_list=[0]*1010

check_list=[0]*1010

n_list[1]=1
n_list[2]=3

check_list[1]=1
check_list[2]=1


i=3

while n_list[n]==0:

   if check_list[i]==0:
       check_list[i]=1
       n_list[i]=n_list[i-1] + 2*n_list[i-2]

   i+=1

print(n_list[n]%796796)


피드백 : 
어차피 점화식을 이용하므로 체크 리스트는 만들 필요가 없었다.
다이나믹 프로그래밍을 이용하는 문제가 생긴다면 아래와 같이 하면 좋을 것 같다.
첫번째로 경우의 수를 파악한다.
두번째로 경우의 수에 맞게 트리를 그려본다.
세번째로 점화식을 세운다.

수학적인 방법으로 굳이 구할 필요는 없을 것 같다는 생각이 든다.




'''


'''

효율적인 화폐 구성 설계

문제 :
N가지 종류의 화폐가 있다.
이 화폐들의 개수를 최소한으로 이용해서 그 가치의 합이 M원이 되도록 하려고 한다.
이때 각 화폐는 몇 개라도 사용할 수 있으며, 
사용한 화폐의 구성이 같은 경우 같은 경우로 구분한다.
M을 만들 수 있는 최소한의 화폐 수를 구하여라


입력 :
1. n[1,100], m[1,10000]     자연수
2~n+1. n개의 줄에 각화퍠의 가치가 입력된다.

출력 :
M원을 만들기 위한 최소한의 화폐수 or -1


아이디어 :
트리에 n가지 경우의 수에 대하여 각각 n가지 경우의 수의 가지를 뻗으면
n^2이 된다. n==100,m==10000이면 100^100이므로 너무 경우의수가 커서 시간초과가 발생한다.
그리고 작은 문제들이 결합이되어 큰문제를 해결하므로 
중복이 되는 작은 문제를 중복되지 않도록하는 다이나믹 프로그래밍으로 문제를 풀 수 있다.

0부터 시작해서 n개의 경우의 수를 모두 더하면서 
그 k까지 더한 화폐의 수인 count(트리의 깊이)를 리스트의 k번째 인덱스에 해당하는 곳에 저장한다.
min을 이용해서 더 작은 count로 리스트를 초기화 시키자 
모든 리프 노드의 카운트가 m보다 커지면 불가능한 것이므로 -1을 출력한다.


설계 :
1. n,m 입력받기
2. n_list 입력받기
3. 무한 루프 (탈출 조건 : 모든 리프 노드의 인덱스 값이 m보다 더 커졌을 때 )
4. 큐에 있는 값을 하나 pop해서 n_list에 있는 값을 모두 더하며 
더한 값을 인덱스로 하는 count_list의 값이 0이고 인덱스가 m보다 작으면 
count_list를 초기화한 후에 큐에 넣기
5. 결과 출력하기


내가 처음 구현한 코드 :

from collections import deque

n,m=map(int,input().split())

n_list=[]

queue=deque([[0,0]])  # 값, 카운트

for i in range(n):
    element=int(input())
    n_list.append(element)

count_list=[0]*10010

while queue:
    start=queue.popleft()
    
    for i in n_list:
        if count_list[start[0]+i]==0 and start[0]+i<=m:
            count_list[start[0]+i] = start[1]+1
            queue.append([start[0]+i,start[1]+1])

if count_list[m]==0:
    print(-1)
else:
    print(count_list[m])

    
피드백 :
점화식이 직관적으로 바로 떠오르지 않아서
큐로 구현을 하였다.
수학적인 방법은 휴먼에러를 발생하기 쉬우므로 
직관적이지 않다면 오류에 주의해야한다.
큐로 구현해서 다이나믹 프로그래밍을 전부 구현할 수 있는지 알아봐야겠다.
점화식을 구하면 간단하게 구현할 수 있지만 
점화식이 직관적이지 않다면 점화식을 구하는데 시간을 많이 빼앗길 수 있으므로
차선책으로 큐를 이용하는 방법을 사용해야겠다.

 
책에 K는 M을 의미하는 듯하다
저자가 세운 점화식은 아래와 같다.

금액 i를 만들 수 있는 최소한의 화폐 개수를 a(i), 화폐의 단위를 k라고 하자
a(i-k)는 금액 (i-k)를 만들 수 있는 최소한의 화폐 개수를 의미한다.
1. a(i-k)를 만드는 방법이 존재하는 경우, a(i)=min(a(k),a(i-k)+1)
2. a(i-k)를 만드는 방법이 존재하지 않는 경우 a(i)=저자가 임의로 정한 값인 10001



저자가 구현한 코드 :

n,m=map(int,input())

array= []
for i in range(n):
    array.append(int(input()))

d=[10001]*(m+1)

d[0]=0
for i in range(n):
    for j in range(array[i],m+1):
        if d[j-array[i]] != 10001:
            d[j] = min(d[j],d[j-array[i]]+1)

if d[m]==10001:
    print(-1)
else:
    print(d[m])


'''











































